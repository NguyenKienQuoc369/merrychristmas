<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>C√¢y Th√¥ng & Tr√°i Tim Chu·∫©n - Bao Anh</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background-color: #02020a; font-family: 'Arial', sans-serif; }
    #canvas-container { width: 100%; height: 100vh; background: radial-gradient(circle at center bottom, #1b2949 0%, #000000 90%); }
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95); z-index: 100; display: flex;
      flex-direction: column; justify-content: center; align-items: center; color: #fff;
    }
    #start-btn {
      padding: 15px 50px; font-size: 24px; background: #e60023; color: #fff; font-weight: bold;
      border: none; border-radius: 50px; cursor: pointer; margin-top: 20px;
      box-shadow: 0 0 20px #ff0000; transition: transform 0.2s;
    }
    #start-btn:hover { transform: scale(1.1); background: #ff1a1a; }
    #status-container { position: absolute; top: 30px; width: 100%; text-align: center; pointer-events: none; z-index: 50; }
    #status-msg {
      display: inline-block; background: rgba(0, 0, 0, 0.6); padding: 10px 30px;
      border-radius: 30px; color: #00ffcc; font-size: 24px; font-weight: bold;
      border: 1px solid rgba(255,255,255,0.3); text-shadow: 0 0 10px rgba(0,255,204,0.8);
    }
  </style>
</head>
<body>

<div id="start-screen">
  <h1 style="text-shadow: 0 0 20px gold;">üéÑ GI√ÅNG SINH & T√åNH Y√äU ‚ù§Ô∏è</h1>
  <p>ƒê√£ s·ª≠a d√°ng tr√°i tim chu·∫©n & n√¢ng c√¢y th√¥ng</p>
  <button id="start-btn">B·∫ÆT ƒê·∫¶U</button>
</div>

<div id="status-container"><div id="status-msg">B·∫•m B·∫ÆT ƒê·∫¶U nh√©...</div></div>
<div id="canvas-container"></div>
<video id="input-video" style="display:none" playsinline></video>

<script>
// --- C·∫§U H√åNH ---
const CONFIG = {
  particleCount: 18000,
  treeHeight: 280,   // Chi·ªÅu cao c√¢y
  treeBaseRadius: 130,
  trunkHeight: 40,
  colors: {
    leaf: new THREE.Color(0x0f6e2b),
    leafLight: new THREE.Color(0x38ff75),
    trunk: new THREE.Color(0x5c3a1d),
    star: new THREE.Color(0xffff00),
    heart: new THREE.Color(0xff0000), // ƒê·ªè t∆∞∆°i
    lights: [0xff0000, 0xffff00, 0x0088ff, 0xff00ff].map(c => new THREE.Color(c))
  }
};

let scene, camera, renderer, particleSystem;
let treeData = [], heartData = [], snowData = [];
let handOpen = false;
let handPos = new THREE.Vector3(0, 0, 0);
let time = 0;
let isRunning = false;
let heartPhotoGroup = null;
const heartPhotoTarget = new THREE.Vector3();
const statusMsg = document.getElementById('status-msg');
const snowCount = 2000;

// --- TEXTURE ƒê·ªêM S√ÅNG ---
function createGlowTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 32; canvas.height = 32;
  const ctx = canvas.getContext('2d');
  const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
  grad.addColorStop(0, 'rgba(255,255,255,1)');
  grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,32,32);
  return new THREE.CanvasTexture(canvas);
}

// --- T·∫†O D·ªÆ LI·ªÜU ---
function generateTargets() {
  treeData = []; heartData = [];
  
  // 1. C√ÇY TH√îNG (ƒê√£ n√¢ng cao v·ªã tr√≠)
  const treeStartY = -100; // ƒê·∫©y l√™n cao h∆°n (b·∫£n c≈© l√† -160)

  // G·ªëc c√¢y
  for(let i=0; i<1000; i++) {
    const h = Math.random() * CONFIG.trunkHeight;
    const r = Math.sqrt(Math.random()) * 25;
    const a = Math.random() * Math.PI * 2;
    treeData.push({
      x: Math.cos(a)*r, y: treeStartY + h, z: Math.sin(a)*r,
      c: CONFIG.colors.trunk, s: 6
    });
  }

  // L√° c√¢y
  const foliageCount = CONFIG.particleCount - 1000 - 100;
  for(let i=0; i<foliageCount; i++) {
    const p = i / foliageCount; // 0 (ƒë√°y) -> 1 (ƒë·ªânh)
    const h = p * CONFIG.treeHeight;
    const rBase = CONFIG.treeBaseRadius * (1 - p);
    const r = Math.sqrt(Math.random()) * rBase * (0.8 + Math.random()*0.4); // T√°n l√° x√≤e t·ª± nhi√™n
    const a = i * 2.4; // G√≥c v√†ng

    const x = Math.cos(a)*r;
    const z = Math.sin(a)*r;
    const y = treeStartY + CONFIG.trunkHeight + h - 10;

    let c = CONFIG.colors.leaf;
    let s = 4;
    let isLight = false;

    // 10% l√† ƒë√®n
    if(Math.random() < 0.1) {
      c = CONFIG.colors.lights[Math.floor(Math.random()*CONFIG.colors.lights.length)];
      s = 10;
      isLight = true;
    } else {
       // M√†u l√° random nh·∫π
       c = Math.random() > 0.5 ? CONFIG.colors.leaf : CONFIG.colors.leafLight;
    }

    treeData.push({ x, y, z, c, s, isLight });
  }

  // Sao ƒë·ªânh - 3 particles gom s√°t nhau ·ªü ƒë√∫ng ƒë·ªânh
  for(let i=0; i<3; i++) {
    treeData.push({
      x: (Math.random()-0.5)*1.5,  // R·∫•t s√°t nhau
      y: treeStartY + CONFIG.trunkHeight + CONFIG.treeHeight,  // Ch√≠nh x√°c ƒë·ªânh
      z: (Math.random()-0.5)*1.5,  // R·∫•t s√°t nhau
      c: CONFIG.colors.star, s: 20, isLight: true
    });
  }

  // 2. TR√ÅI TIM (S·ª≠a l·∫°i c√¥ng th·ª©c chu·∫©n)
  // S·ª≠ d·ª•ng c√¥ng th·ª©c Parametric Heart Curve
  for(let i=0; i<CONFIG.particleCount; i++) {
    const t = Math.random() * Math.PI * 2;
    
    // Quan tr·ªçng: Ph√¢n b·ªë h·∫°t t·∫≠p trung v√†o vi·ªÅn (shell) ƒë·ªÉ r√µ n√©t
    // Math.pow(Math.random(), 0.1) s·∫Ω ƒë·∫©y c√°c gi√° tr·ªã v·ªÅ g·∫ßn 1
    const r = Math.pow(Math.random(), 0.15); 
    
    // C√¥ng th·ª©c tim 2D chu·∫©n
    let x = 16 * Math.pow(Math.sin(t), 3);
    let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    
    // Scale to
    const scale = 12; 
    x *= scale * r;
    y *= scale * r;

    // T·∫°o ƒë·ªô d√†y Z v·ª´a ph·∫£i (kh√¥ng qu√° d√†y ƒë·ªÉ tr√°nh th√†nh c·ªß khoai)
    // ƒê·ªô d√†y gi·∫£m d·∫ßn v·ªÅ ph√≠a ƒëu√¥i tim
    const thickness = 30 * r; 
    let z = (Math.random() - 0.5) * thickness; 
    
    // ƒê·∫©y tim l√™n cao
    y += 120; 

    heartData.push({
      x: x, y: y, z: z,
      c: CONFIG.colors.heart, // ƒê·ªè r·ª±c
      s: 5 + Math.random() * 3
    });
  }
}

// --- T·∫†O TUY·∫æT R∆†I ---
function generateSnow() {
  snowData = [];
  const screenWidth = 500; // Ph·∫°m vi X camera
  const screenHeight = 400; // Ph·∫°m vi Y camera
  
  for(let i=0; i<snowCount; i++) {
    const x = (Math.random() - 0.5) * screenWidth;
    const y = (Math.random() - 0.5) * screenHeight + 350; // Spawn cao ph√≠a tr√™n
    const z = (Math.random() - 0.5) * 300;
    const speed = 0.5 + Math.random() * 0.5; // T·ªëc ƒë·ªô r∆°i
    
    snowData.push({
      x: x, y: y, z: z,
      c: { r: 0.95, g: 0.95, b: 1.0 }, // Tr·∫Øng nh·∫π xanh
      s: 2 + Math.random() * 2,
      speed: speed,
      initialX: x,
      initialZ: z,
      phase: Math.random() * Math.PI * 2
    });
  }
}

// --- ·∫¢NH TRONG TIM ---
function createHeartPhoto() {
  const group = new THREE.Group();

  // Frame m·∫£nh quanh ·∫£nh
  const frameSize = 120;
  const frameGeo = new THREE.PlaneGeometry(frameSize, frameSize);
  const frameMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.85, side: THREE.DoubleSide });
  const frame = new THREE.Mesh(frameGeo, frameMat);
  group.add(frame);

  // ·∫¢nh baoanh.jpg ·ªü gi·ªØa
  const loader = new THREE.TextureLoader();
  loader.setCrossOrigin('anonymous');
  loader.load('/baoanh.jpg', tex => {
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    const photoGeo = new THREE.PlaneGeometry(110, 110);
    const photoMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
    const photo = new THREE.Mesh(photoGeo, photoMat);
    photo.position.set(0, 0, 0.2); // h∆°i nh√¥ ra ƒë·ªÉ kh√¥ng tr√πng frame
    group.add(photo);
  }, undefined, err => {
    console.warn('Load baoanh.jpg failed', err);
  });

  group.visible = false;
  scene.add(group);
  heartPhotoGroup = group;
}

// --- THREE.JS SETUP ---
function initThree() {
  const container = document.getElementById('canvas-container');
  scene = new THREE.Scene();
  // S∆∞∆°ng m√π t·ªëi
  scene.fog = new THREE.FogExp2(0x1b2949, 0.001);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
  camera.position.set(0, 100, 450); // Camera nh√¨n th·∫≥ng
  camera.lookAt(0, 80, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.appendChild(renderer.domElement);

  generateTargets();
  generateSnow();

  // ·∫¢nh tim
  createHeartPhoto();

  const geom = new THREE.BufferGeometry();
  const totalParticles = CONFIG.particleCount + snowCount;
  const pos = new Float32Array(totalParticles * 3);
  const col = new Float32Array(totalParticles * 3);
  const size = new Float32Array(totalParticles);

  // Init tree/heart data
  for(let i=0; i<CONFIG.particleCount; i++) {
    const d = treeData[i % treeData.length];
    pos[i*3] = d.x; pos[i*3+1] = d.y; pos[i*3+2] = d.z;
    col[i*3] = d.c.r; col[i*3+1] = d.c.g; col[i*3+2] = d.c.b;
    size[i] = d.s;
  }

  // Init snow data
  for(let i=0; i<snowCount; i++) {
    const idx = CONFIG.particleCount + i;
    const d = snowData[i];
    pos[idx*3] = d.x; pos[idx*3+1] = d.y; pos[idx*3+2] = d.z;
    col[idx*3] = d.c.r; col[idx*3+1] = d.c.g; col[idx*3+2] = d.c.b;
    size[idx] = d.s;
  }

  geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geom.setAttribute('color', new THREE.BufferAttribute(col, 3));
  geom.setAttribute('size', new THREE.BufferAttribute(size, 1));

  const mat = new THREE.ShaderMaterial({
    uniforms: { tex: { value: createGlowTexture() } },
    vertexShader: `
      attribute float size; varying vec3 vC;
      void main() {
        vC = color;
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (300.0 / -mv.z);
        gl_Position = projectionMatrix * mv;
      }
    `,
    fragmentShader: `
      uniform sampler2D tex; varying vec3 vC;
      void main() {
        vec4 t = texture2D(tex, gl_PointCoord);
        if(t.a < 0.1) discard;
        gl_FragColor = vec4(vC, t.a);
      }
    `,
    blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, vertexColors: true
  });

  particleSystem = new THREE.Points(geom, mat);
  scene.add(particleSystem);
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function animate() {
  if(!isRunning) return;
  requestAnimationFrame(animate);
  time += 0.02;

  const positions = particleSystem.geometry.attributes.position.array;
  const colors = particleSystem.geometry.attributes.color.array;
  const sizes = particleSystem.geometry.attributes.size.array;

  // Tim ƒë·∫≠p
  const beat = handOpen ? 1 + Math.sin(time*5)*0.05 : 1;
  const lerpVal = 0.06;

  for(let i=0; i<CONFIG.particleCount; i++) {
    const i3 = i*3;
    let tx, ty, tz, tr, tg, tb, ts;
    
    // Map index c·∫©n th·∫≠n
    const tItem = treeData[i % treeData.length];
    const hItem = heartData[i % heartData.length];

    if(handOpen) {
      // HEART MODE
      tx = hItem.x * beat + handPos.x;
      ty = hItem.y * beat + handPos.y;
      tz = hItem.z * beat + handPos.z;
      tr = hItem.c.r; tg = hItem.c.g; tb = hItem.c.b;
      ts = hItem.s;
    } else {
      // TREE MODE
      tx = tItem.x + handPos.x;
      ty = tItem.y + handPos.y;
      tz = tItem.z + handPos.z;
      tr = tItem.c.r; tg = tItem.c.g; tb = tItem.c.b;
      ts = tItem.s;
      
      // Nh·∫•p nh√°y ƒë√®n
      if(tItem.isLight) {
        const blink = Math.sin(time*3 + i)*0.5 + 0.5;
        tr *= (0.5 + blink); tg *= (0.5 + blink); tb *= (0.5 + blink);
        ts *= (0.8 + blink*0.4);
      }
    }

    positions[i3] += (tx - positions[i3]) * lerpVal;
    positions[i3+1] += (ty - positions[i3+1]) * lerpVal;
    positions[i3+2] += (tz - positions[i3+2]) * lerpVal;
    
    colors[i3] += (tr - colors[i3]) * lerpVal;
    colors[i3+1] += (tg - colors[i3+1]) * lerpVal;
    colors[i3+2] += (tb - colors[i3+2]) * lerpVal;
    
    sizes[i] += (ts - sizes[i]) * lerpVal;
  }

  // ·∫¢nh ·ªü gi·ªØa tim
  if(heartPhotoGroup) {
    heartPhotoGroup.visible = handOpen;
    const targetY = handPos.y + 120 * beat; // tim ƒë√£ d·ªãch l√™n 120
    heartPhotoTarget.set(handPos.x, targetY, handPos.z);
    heartPhotoGroup.position.lerp(heartPhotoTarget, 0.08);
    const photoScale = 0.9 * beat;
    heartPhotoGroup.scale.set(photoScale, photoScale, photoScale);
    heartPhotoGroup.lookAt(camera.position);
  }

  // Update snow particles
  for(let i=0; i<snowCount; i++) {
    const idx = CONFIG.particleCount + i;
    const i3 = idx * 3;
    const s = snowData[i];
    
    // Tuy·∫øt r∆°i xu·ªëng (chuy·ªÉn ƒë·ªông Y gi·∫£m)
    s.y -= s.speed;
    
    // Chuy·ªÉn ƒë·ªông s√≥ng ngang (l·∫Øc l∆∞)
    s.x = s.initialX + Math.sin(time * 2 + s.phase) * 20;
    s.z = s.initialZ + Math.cos(time * 1.5 + s.phase) * 20;
    
    // Khi tuy·∫øt r∆°i xu·ªëng d∆∞·ªõi m√†n h√¨nh, reset l√™n tr√™n
    if(s.y < -300) {
      s.y = 350;
    }
    
    positions[i3] = s.x;
    positions[i3+1] = s.y;
    positions[i3+2] = s.z;
    
    colors[i3] = s.c.r;
    colors[i3+1] = s.c.g;
    colors[i3+2] = s.c.b;
    
    sizes[idx] = s.s;
  }

  particleSystem.geometry.attributes.position.needsUpdate = true;
  particleSystem.geometry.attributes.color.needsUpdate = true;
  particleSystem.geometry.attributes.size.needsUpdate = true;
  
  // Xoay nh·∫π
  particleSystem.rotation.y = Math.sin(time*0.1)*0.15;
  
  renderer.render(scene, camera);
}

// --- AI SETUP ---
async function startApp() {
  document.getElementById('start-screen').style.display = 'none';
  statusMsg.innerText = "ƒêang m·ªü m·∫Øt th·∫ßn (Camera)...";
  
  initThree();
  isRunning = true; 
  animate();

  const video = document.getElementById('input-video');
  const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
  hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
  
  hands.onResults(results => {
    if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
      const lm = results.multiHandLandmarks[0];
      
      // Check m·ªü tay
      const tips = [8,12,16,20]; const pips = [6,10,14,18];
      let open = 0;
      tips.forEach((t,i) => { if(lm[t].y < lm[pips[i]].y) open++; });
      
      const isOpen = open >= 3;
      if(isOpen !== handOpen) {
        handOpen = isOpen;
        statusMsg.innerText = handOpen ? "‚ù§Ô∏è Y√™u em ‚ù§Ô∏è" : "üéÑ MERRY CHRISTMAS üéÑ";
        statusMsg.style.color = handOpen ? "#ff0000" : "#00ffcc";
      }
      
      // Di chuy·ªÉn theo tay
      const x = (1 - lm[0].x - 0.5) * 350;
      const y = (0.5 - lm[0].y) * 250;
      handPos.x += (x - handPos.x) * 0.1;
      handPos.y += (y - handPos.y) * 0.1;
    }
  });

  const camera = new Camera(video, {
    onFrame: async () => { await hands.send({image: video}); },
    width: 480, height: 360
  });
  
  await camera.start();
  statusMsg.innerText = "Xong! N·∫Øm/X√≤e tay ƒë·ªÉ th·ª≠ n√†o";
}

document.getElementById('start-btn').addEventListener('click', startApp);
</script>
</body>
</html>